// Blinky
const unsigned char blinky_right_00[] = { 0, 0, 8, 8, 0, 10, METASPRITE_END };
const unsigned char blinky_right_01[] = { 0, 0, 12, 8, 0, 14, METASPRITE_END };
const unsigned char *blinky_right_frames[] = { blinky_right_00, blinky_right_01 };
const unsigned char blinky_down_00[] = { 0, 0, 16, 8, 0, 18, METASPRITE_END };
const unsigned char blinky_down_01[] = { 0, 0, 20, 8, 0, 22, METASPRITE_END };
const unsigned char *blinky_down_frames[] = { blinky_down_00, blinky_down_01 };
const unsigned char blinky_left_00[] = { 0, 0, 24, 8, 0, 26, METASPRITE_END };
const unsigned char blinky_left_01[] = { 0, 0, 28, 8, 0, 30, METASPRITE_END };
const unsigned char *blinky_left_frames[] = { blinky_left_00, blinky_left_01 };
const unsigned char blinky_up_00[] = { 0, 0, 32, 8, 0, 34, METASPRITE_END };
const unsigned char blinky_up_01[] = { 0, 0, 36, 8, 0, 38, METASPRITE_END };
const unsigned char *blinky_up_frames[] = { blinky_up_00, blinky_up_01 };

// Pinky
const unsigned char pinky_right_00[] = { 0, 0, 40, 8, 0, 42, METASPRITE_END };
const unsigned char pinky_right_01[] = { 0, 0, 44, 8, 0, 46, METASPRITE_END };
const unsigned char *pinky_right_frames[] = { pinky_right_00, pinky_right_01 };
const unsigned char pinky_down_00[] = { 0, 0, 48, 8, 0, 50, METASPRITE_END };
const unsigned char pinky_down_01[] = { 0, 0, 52, 8, 0, 54, METASPRITE_END };
const unsigned char *pinky_down_frames[] = { pinky_down_00, pinky_down_01 };
const unsigned char pinky_left_00[] = { 0, 0, 56, 8, 0, 58, METASPRITE_END };
const unsigned char pinky_left_01[] = { 0, 0, 60, 8, 0, 62, METASPRITE_END };
const unsigned char *pinky_left_frames[] = { pinky_left_00, pinky_left_01 };
const unsigned char pinky_up_00[] = { 0, 0, 64, 8, 0, 66, METASPRITE_END };
const unsigned char pinky_up_01[] = { 0, 0, 68, 8, 0, 70, METASPRITE_END };
const unsigned char *pinky_up_frames[] = { pinky_up_00, pinky_up_01 };

// Inky
const unsigned char inky_right_00[] = { 0, 0, 72, 8, 0, 74, METASPRITE_END };
const unsigned char inky_right_01[] = { 0, 0, 76, 8, 0, 78, METASPRITE_END };
const unsigned char *inky_right_frames[] = { inky_right_00, inky_right_01 };
const unsigned char inky_down_00[] = { 0, 0, 80, 8, 0, 82, METASPRITE_END };
const unsigned char inky_down_01[] = { 0, 0, 84, 8, 0, 86, METASPRITE_END };
const unsigned char *inky_down_frames[] = { inky_down_00, inky_down_01 };
const unsigned char inky_left_00[] = { 0, 0, 88, 8, 0, 90, METASPRITE_END };
const unsigned char inky_left_01[] = { 0, 0, 92, 8, 0, 94, METASPRITE_END };
const unsigned char *inky_left_frames[] = { inky_left_00, inky_left_01 };
const unsigned char inky_up_00[] = { 0, 0, 96, 8, 0, 98, METASPRITE_END };
const unsigned char inky_up_01[] = { 0, 0, 100, 8, 0, 102, METASPRITE_END };
const unsigned char *inky_up_frames[] = { inky_up_00, inky_up_01 };

// Sue
const unsigned char sue_right_00[] = { 0, 0, 104, 8, 0, 106, METASPRITE_END };
const unsigned char sue_right_01[] = { 0, 0, 108, 8, 0, 110, METASPRITE_END };
const unsigned char *sue_right_frames[] = { sue_right_00, sue_right_01 };
const unsigned char sue_down_00[] = { 0, 0, 112, 8, 0, 114, METASPRITE_END };
const unsigned char sue_down_01[] = { 0, 0, 116, 8, 0, 118, METASPRITE_END };
const unsigned char *sue_down_frames[] = { sue_down_00, sue_down_01 };
const unsigned char sue_left_00[] = { 0, 0, 120, 8, 0, 122, METASPRITE_END };
const unsigned char sue_left_01[] = { 0, 0, 124, 8, 0, 126, METASPRITE_END };
const unsigned char *sue_left_frames[] = { sue_left_00, sue_left_01 };
const unsigned char sue_up_00[] = { 0, 0, 128, 8, 0, 130, METASPRITE_END };
const unsigned char sue_up_01[] = { 0, 0, 132, 8, 0, 134, METASPRITE_END };
const unsigned char *sue_up_frames[] = { sue_up_00, sue_up_01 };

// Frightened
const unsigned char frightened_00[] = { 0, 0, 136, 8, 0, 138, METASPRITE_END };
const unsigned char frightened_01[] = { 0, 0, 140, 8, 0, 142, METASPRITE_END };
const unsigned char *frightened_frames[] = { frightened_00, frightened_01, frightened_00, frightened_01 };

// Flashing
const unsigned char flashing_00[] = { 0, 0, 144, 8, 0, 146, METASPRITE_END };
const unsigned char flashing_01[] = { 0, 0, 148, 8, 0, 150, METASPRITE_END };
const unsigned char *flashing_frames[] = { frightened_00, frightened_01, flashing_00, flashing_01 };

// Chomped
const unsigned char chomped_right[] = { 0, 0, 152, 8, 0, 154, METASPRITE_END };
const unsigned char chomped_down[] = { 0, 0, 156, 8, 0, 158, METASPRITE_END };
const unsigned char chomped_left[] = { 0, 0, 160, 8, 0, 162, METASPRITE_END };
const unsigned char chomped_up[] = { 0, 0, 164, 8, 0, 166, METASPRITE_END };
const unsigned char *chomped_dirs[] = { chomped_right, chomped_down, chomped_left, chomped_up };

// Down markers
const unsigned char blinky_down_marker[] = { 0, 0, 168, 8, 0, 170, METASPRITE_END };
const unsigned char pinky_down_marker[] = { 0, 0, 176, 8, 0, 178, METASPRITE_END };
const unsigned char inky_down_marker[] = { 0, 0, 184, 8, 0, 186, METASPRITE_END };
const unsigned char sue_down_marker[] = { 0, 0, 192, 8, 0, 194, METASPRITE_END };
const unsigned char *ghost_down_markers[] = { blinky_down_marker, pinky_down_marker, inky_down_marker, sue_down_marker };

// Up markers
const unsigned char blinky_up_marker[] = { 0, 0, 172, 8, 0, 174, METASPRITE_END };
const unsigned char pinky_up_marker[] = { 0, 0, 180, 8, 0, 182, METASPRITE_END };
const unsigned char inky_up_marker[] = { 0, 0, 188, 8, 0, 190, METASPRITE_END };
const unsigned char sue_up_marker[] = { 0, 0, 196, 8, 0, 198, METASPRITE_END };
const unsigned char *ghost_up_markers[] = { blinky_up_marker, pinky_up_marker, inky_up_marker, sue_up_marker };

// Frightened ghost markers
const unsigned char frightened_down_marker[] = { 0, 0, 200, 8, 0, 202, METASPRITE_END };
const unsigned char frightened_up_marker[] = { 0, 0, 204, 8, 0, 206, METASPRITE_END };

// Points
const unsigned char points_200[] = { 0, 0, 208, 8, 0, 210, METASPRITE_END };
const unsigned char points_400[] = { 0, 0, 212, 8, 0, 210, METASPRITE_END };
const unsigned char points_800[] = { 0, 0, 214, 8, 0, 210, METASPRITE_END };
const unsigned char points_1600[] = { 0, 0, 216, 8, 0, 218, METASPRITE_END };

// Test marker
const unsigned char ghost_marker[] = { 0, 0, 244, METASPRITE_END };

// Sets ghost data
void SetGhost(unsigned char index, unsigned char dir, unsigned char state, unsigned short x, unsigned short y) {
    EntityX[index] = x;
    EntityY[index] = y;
    EntityDir[index] = dir;
    EntityState[index] = state;
    EntitySubState[index] = ENTITY_STATE_NONE;
    EntityTimer[index] = 0;
    EntityLutIndex[index] = 0;
    EntityTargetTile[index] = 0;
    EntityFrame[index] = 0;
    EntityFrameDuration[index] = -1;
}

// Updates test marker sprites
void UpdateTestMarker(unsigned char index, unsigned char state) {
    // If the ghost is in a state we shouldn't override, return
    if (EntityState[index] > ENTITY_STATE_POINTS) {
        return;
    }
    // Force given state on ghost
    EntityState[index] = state;
    // Set the target position to misc entity
    SetEntityPositionByTileIndex(INDEX_MISC, EntityTargetTile[index]);
    // If out of view, return
    if (EntityY[INDEX_MISC] + 16 < ScrollY || EntityY[INDEX_MISC] > (ScrollY + 192)) {
        return;
    }
    // Offset vertical coordinate from hardware scroll
	unsigned char y = EntityY[INDEX_MISC] - ScrollY;
    // Add marker sprite
	SMS_addMetaSprite(EntityX[INDEX_MISC], y, ghost_marker);
}

// Updates ghost sprites
void UpdateGhostSprites(unsigned char index) {
    // Get state
    unsigned char state = EntityState[index];
    // If state is none, return
	if (state == ENTITY_STATE_NONE) {
		return;
	}
    // Set visibility
	SetEntityVisibility(index);
    // Offset coordinates from origin and vertical hardware scroll
    unsigned char x = EntityX[index] - 8;
	unsigned char y = EntityY[index] - ScrollY - 8 + ScrollYAmount;
    // If off screen above view, use top markers
    if (EntityVisibility[index] == OUT_OF_VIEW_TOP) {
        // Frightened marker, flashing
        if (state == ENTITY_STATE_FRIGHTENED && EnergizerTimer <= EnergizerTimerHalf && EntityFrame[index] > 1) {
            SMS_addMetaSprite(x, 0, ghost_up_markers[index]);
        // Frightened marker
        } else if (state == ENTITY_STATE_FRIGHTENED) {
            SMS_addMetaSprite(x, 0, frightened_up_marker);
        // Ghost marker
        } else {
            SMS_addMetaSprite(x, 0, ghost_up_markers[index]);
        }
        return;
    // If off screen below view, use bottom markers
    } else if (EntityVisibility[index] == OUT_OF_VIEW_BOTTOM) {
        // Frightened marker, flashing
        if (state == ENTITY_STATE_FRIGHTENED && EnergizerTimer <= EnergizerTimerHalf && EntityFrame[index] > 1) {
            SMS_addMetaSprite(x, 176, ghost_down_markers[index]);
        // Frightened marker
        } else if (state == ENTITY_STATE_FRIGHTENED) {
            SMS_addMetaSprite(x, 176, frightened_down_marker);
        // Ghost marker
        } else {
            SMS_addMetaSprite(x, 176, ghost_down_markers[index]);
        }
        return;
    }
    // If bouncing, add offset
    if (EntitySubState[index] == ENTITY_STATE_BOUNCING) {
        EntityLutIndex[index] = EntityLutIndex[index] + 1 >= sizeof(Bounce) ? 0 : EntityLutIndex[index] + 1;
        y += Bounce[EntityLutIndex[index]];
    }
    // Normal sprites
    // Frightened
    switch (state) {
        case ENTITY_STATE_FRIGHTENED:
            // If not flashing
            if (EnergizerTimer >= EnergizerTimerHalf) {
                SMS_addMetaSprite(x, y, frightened_frames[EntityFrame[index]]);
            // Flashing
            } else {
                SMS_addMetaSprite(x, y, flashing_frames[EntityFrame[index]]);
            }
        break;
        // If chomped or going bask to the ghost house (Ghost eyes)
        case ENTITY_STATE_CHOMPED:
        case ENTITY_STATE_ENTERING:
            SMS_addMetaSprite(x, y, chomped_dirs[EntityDir[index]]);
        break;
        // If displaying point value after being chomped
        case ENTITY_STATE_POINTS:
            switch (GhostPointAcc) {
                case 200: SMS_addMetaSprite(x, y, points_200); break;
                case 400: SMS_addMetaSprite(x, y, points_400); break;
                case 800: SMS_addMetaSprite(x, y, points_800); break;
                case 1600: SMS_addMetaSprite(x, y, points_1600); break;
            }
        break;
        // Default graphics
        default:
            switch (index) {
                case INDEX_BLINKY:
                    switch (EntityDir[index]) {
                        case DIRECTION_RIGHT: SMS_addMetaSprite(x, y, blinky_right_frames[EntityFrame[index]]); break;
                        case DIRECTION_DOWN: SMS_addMetaSprite(x, y, blinky_down_frames[EntityFrame[index]]); break;
                        case DIRECTION_LEFT: SMS_addMetaSprite(x, y, blinky_left_frames[EntityFrame[index]]); break;
                        case DIRECTION_UP: SMS_addMetaSprite(x, y, blinky_up_frames[EntityFrame[index]]); break;
                    }
                break;
                case INDEX_PINKY:
                    switch (EntityDir[index]) {
                        case DIRECTION_RIGHT: SMS_addMetaSprite(x, y, pinky_right_frames[EntityFrame[index]]); break;
                        case DIRECTION_DOWN: SMS_addMetaSprite(x, y, pinky_down_frames[EntityFrame[index]]); break;
                        case DIRECTION_LEFT: SMS_addMetaSprite(x, y, pinky_left_frames[EntityFrame[index]]); break;
                        case DIRECTION_UP: SMS_addMetaSprite(x, y, pinky_up_frames[EntityFrame[index]]); break;
                    }
                break;
                case INDEX_INKY:
                    switch (EntityDir[index]) {
                        case DIRECTION_RIGHT: SMS_addMetaSprite(x, y, inky_right_frames[EntityFrame[index]]); break;
                        case DIRECTION_DOWN: SMS_addMetaSprite(x, y, inky_down_frames[EntityFrame[index]]); break;
                        case DIRECTION_LEFT: SMS_addMetaSprite(x, y, inky_left_frames[EntityFrame[index]]); break;
                        case DIRECTION_UP: SMS_addMetaSprite(x, y, inky_up_frames[EntityFrame[index]]); break;
                    }
                break;
                case INDEX_SUE:
                    switch (EntityDir[index]) {
                        case DIRECTION_RIGHT: SMS_addMetaSprite(x, y, sue_right_frames[EntityFrame[index]]); break;
                        case DIRECTION_DOWN: SMS_addMetaSprite(x, y, sue_down_frames[EntityFrame[index]]); break;
                        case DIRECTION_LEFT: SMS_addMetaSprite(x, y, sue_left_frames[EntityFrame[index]]); break;
                        case DIRECTION_UP: SMS_addMetaSprite(x, y, sue_up_frames[EntityFrame[index]]); break;
                    }
                break;
            }
        break;
    }
}

// Updates ghost animation frame
void UpdateGhostFrame(unsigned char index) {
    // If not ready to update frame, return
    if (Paused > 0 || --EntityFrameDuration[index] > -1) {
        return;
    }
    // Get next frame details
    switch (EntityState[index]) {
        // Points or chomped (Ghost eyes)
        case ENTITY_STATE_POINTS:
        case ENTITY_STATE_CHOMPED:
            EntityFrame[index] = 0;
            EntityFrameDuration[index] = 127;
        break;
        case ENTITY_STATE_FRIGHTENED:
            EntityFrame[index] = EntityFrame[index] + 1 >= 4 ? 0 : EntityFrame[index] + 1;
            EntityFrameDuration[index] = TIME_06;
        break;
        // Default frame
        default:
            EntityFrame[index] = EntityFrame[index] + 1 >= 2 ? 0 : EntityFrame[index] + 1;
            EntityFrameDuration[index] = TIME_06;
        break;
    }
}

// Resets frame index and duration
void ResetGhostFrame(unsigned char index) {
    EntityFrame[index] = 0;
    EntityFrameDuration[index] = -1;
}

// Sets the given entity's reverse direction
void SetGhostReverseDirection(unsigned char index) {
    // Reset frame
    ResetGhostFrame(index);
    EntityPrevTile[index] = 0;
    // Get reverse direction
    switch (EntityDir[index]) {
        case DIRECTION_DOWN: EntityDir[index] = DIRECTION_UP; break;
        case DIRECTION_LEFT: EntityDir[index] = DIRECTION_RIGHT; break;
        case DIRECTION_UP: EntityDir[index] = DIRECTION_DOWN; break;
		default: EntityDir[index] = DIRECTION_LEFT; break;
    }
}

// Sets all ghosts to given state
void SetAllGhostStates(unsigned char state) {
    // Stop ghost processing for a frame, as this is an intensive function
    GhostProcessing = 1;
    // Iterate through ghosts
    for (unsigned char i = 0; i < 4; i++) {
        // If frightened, and entity is already frightened, continue
        if (state == ENTITY_STATE_FRIGHTENED && EntityState[i] == ENTITY_STATE_FRIGHTENED) {
            SetGhostReverseDirection(i);
            continue;
        // If current state can't be overridden by new state (Except for state none), continue
        } else if (state != ENTITY_STATE_NONE && EntityState[i] >= ENTITY_STATE_FRIGHTENED) {
            continue;
        // Reverse direction on state change if not state none
        } else if (state != ENTITY_STATE_NONE) {
            SetGhostReverseDirection(i);
        }
        // Set new state fields
        EntityTimer[i] = 0;
        EntityTargetTile[i] = 0;
        EntityState[i] = state;
    }
}

// Set ghost mode
void SetGhostMode(unsigned char ghostMode) {
    if (CurrentPlayer == INDEX_PLAYER_01) {
        P1GhostMode = ghostMode;
    } else {
        P2GhostMode = ghostMode;
    }
    GhostMode = ghostMode;
    SetAllGhostStates(GhostMode);
}

// Checks for player collisions
void GhostCheckCollision(unsigned char index) {
    // If ghost is in a non-collision checked state, return
    if (EntityState[index] > ENTITY_STATE_FRIGHTENED) {
        return;
    }
    // Check for collision with player(s)
	unsigned char target = CheckEntityCollision(index);
    // If no collision occurred, return 0
	if (target == 0) {
		return;
	}
    // Collision occured, pause everything for a bit
    Paused = 2;
    // Ghost chomped
    // If collision happened while ghost was in a frightened state
    if (EntityState[index] == ENTITY_STATE_FRIGHTENED) {
        // Set ghost to points state
        EntityState[index] = ENTITY_STATE_POINTS;
        EntityTarget[index] = target;
        // Hide player
        EntityState[target] = ENTITY_STATE_NONE;
        EntityTimer[index] = 0;
        // Award points and return
        GhostPointAcc = GhostPointAcc == 0 ? 200 : GhostPointAcc << 1;
        switch (GhostPointAcc) {
            case 200: AddScore(target, POINTS_200); PlayTrack(AUDIO_AFTER_GHOST_CHOMPED, 1); break;
            case 400: AddScore(target, POINTS_400); break;
            case 800: AddScore(target, POINTS_800); break;
            case 1600: AddScore(target, POINTS_1600); break;
        }
        PlaySFX(SFX_GHOST_CHOMPED, SFX_CHANNEL2);
        return;
    }
    // Player chomped
    // Set player to chomped
    PSGStop();
    EntityState[target] = ENTITY_STATE_CHOMPED;
    EntityTimer[target] = 0;
    // Set auto scroll direction if player offscreen
    AutoScrollDir = EntityVisibility[target] == OUT_OF_VIEW_TOP ? DIRECTION_UP : EntityVisibility[target] == OUT_OF_VIEW_BOTTOM ? DIRECTION_DOWN : DIRECTION_NONE;
    // Reduce lives
    if (CurrentPlayer == INDEX_PLAYER_01) {
        P1Lives--;
    } else {
        P2Lives--;
    }
}

// Check all available directions around the given tile
void SetGhostAvailableDirections(unsigned short tile, unsigned char dir) {
    // If the opposite direction of the current direction or the next tile is solid, set as zero, else one
    GhostDirs[DIRECTION_RIGHT] = dir == DIRECTION_LEFT ? 0 : GetMapTileId(tile + 1) > TILE_SOLID ? 0 : 1;
    GhostDirs[DIRECTION_DOWN] = dir == DIRECTION_UP ? 0 : GetMapTileId(tile + 32) > TILE_SOLID ? 0 : 1;
    GhostDirs[DIRECTION_LEFT] = dir == DIRECTION_RIGHT ? 0 : GetMapTileId(tile - 1) > TILE_SOLID ? 0 : 1;
    GhostDirs[DIRECTION_UP] = dir == DIRECTION_DOWN ? 0 : GetMapTileId(tile - 32) > TILE_SOLID ? 0 : 1;
    // Add all available directions up
    GhostDirs[DIRECTION_ALL] = GhostDirs[DIRECTION_RIGHT] + GhostDirs[DIRECTION_DOWN] + GhostDirs[DIRECTION_LEFT] + GhostDirs[DIRECTION_UP];
}

// Set ghost's random available direction
void SetRandomGhostDirection(unsigned char index) {
    // Set available ghost directions
    SetGhostAvailableDirections(EntityTile[index], EntityDir[index]);
    // Set random direction
    unsigned char rng = GetRng(6, 0);
    while (GhostDirs[rng] <= 0) {
        rng = (rng + 1) & 3;
    }
    EntityDir[index] = rng;
}

// Set ghost's calculated direction
void SetGhostDirection(unsigned char index, unsigned short target) {
    // Set available ghost directions
    SetGhostAvailableDirections(EntityTile[index], EntityDir[index]);
    // If only one available direction, keep moving in that direction
    if (GhostDirs[DIRECTION_ALL] == 1 && GhostDirs[EntityDir[index]] == 1) {
        return;
    }
    // Set chosen directions
    unsigned short dist = 0;
    unsigned short minDist = 65535;
    // If able to move right
    if (GhostDirs[DIRECTION_RIGHT] > 0) {
        dist = GetDistance(EntityTile[index] + 1, target);
        if (dist <= minDist) {
            minDist = dist;
            EntityDir[index] = DIRECTION_RIGHT;
        }
    }
    // If able to move down
    if (GhostDirs[DIRECTION_DOWN] > 0) {
        dist = GetDistance(EntityTile[index] + 32, target);
        if (dist <= minDist) {
            minDist = dist;
            EntityDir[index] = DIRECTION_DOWN;
        }
    }
    // If able to move left
    if (GhostDirs[DIRECTION_LEFT] > 0) {
        dist = GetDistance(EntityTile[index] - 1, target);
        if (dist <= minDist) {
            minDist = dist;
            EntityDir[index] = DIRECTION_LEFT;
        }
    }
    // If able to move up
    if (GhostDirs[DIRECTION_UP] > 0) {
        dist = GetDistance(EntityTile[index] - 32, target);
        if (dist <= minDist) {
            minDist = dist;
            EntityDir[index] = DIRECTION_UP;
        }
    }
}

// Moves given ghost towards given target tile
void GhostMoveTowardsTarget(unsigned char index, unsigned short target) {
    // Set target
    EntityTargetTile[index] = target;
    // Check for player collisions
    GhostCheckCollision(index);
    // Check screen wraps
    CheckWrap(index);
    // If setting random direction
    if (target == 65535) {
        SetRandomGhostDirection(index);
    } else {
        SetGhostDirection(index, target);
    }
    // Update previous tile position
    EntityPrevTile[index] = EntityTile[index];
    // Snap to mid tile
    EntitySnapTile(index, EntityDir[index]);
    // Move to available direction
    MoveEntity(index, EntityDir[index]);
}

// Processes ghost in house state
void GhostHouse(unsigned char index) {
    // Going up and down. Check upper and lower boundary limits, set dir when boundaries are hit
    if (EntityY[index] <= 136) {
        EntityDir[index] = DIRECTION_DOWN;
    } else if (EntityY[index] >= 144) {
        EntityDir[index] = DIRECTION_UP;
    }
    // Move ghost up or down
    MoveEntity(index, EntityDir[index]);
    // Timer release from ghost house, Blinky and Pinky are instant
    switch (index) {
        case INDEX_INKY:
            // If stage 1, and exceeded the ghost mode timer, leave ghost house
            if (Stage == 0 && GhostModeTimer >= 280) {
                EntityState[index] = ENTITY_STATE_LEAVING;
            // Stage doesn't have a wait, leave
            } else {
                EntityState[index] = ENTITY_STATE_LEAVING;
            }
        break;
        case INDEX_SUE:
            // If greater than stage 2, stage doesn't have a wait, leave
            if (Stage > 1) {
                EntityState[index] = ENTITY_STATE_LEAVING;
            // If stage 1, and exceeded 6 seconds, leave ghost house
            } else if (Stage == 0 && GhostModeTimer >= 420) {
                EntityState[index] = ENTITY_STATE_LEAVING;
            // If stage 2, and exceeded 5 seconds, leave ghost house
            } else if (Stage == 1 && GhostModeTimer >= 350) {
                EntityState[index] = ENTITY_STATE_LEAVING;
            }
        break;
    }
}

// Processes leaving ghost house state
void GhostLeaving(unsigned char index) {
    // If right of horizontal center of ghost house, move left
    if (EntityX[index] > 128) {
        EntityDir[index] = DIRECTION_LEFT;
        MoveEntity(index, DIRECTION_LEFT);
    // If left of horizontal center of ghost house, move right
    } else if (EntityX[index] < 128) {
        EntityDir[index] = DIRECTION_RIGHT;
        MoveEntity(index, DIRECTION_RIGHT);
    // At center, move up
    } else {
        EntityDir[index] = DIRECTION_UP;
        MoveEntity(index, DIRECTION_UP);
    }
    // If out of ghost house
    if (EntityY[index] <= 116) {
        // Lock in vertical position, set to current ghost mode (Scatterng, Chasing)
        EntityY[index] = 116;
        EntityState[index] = GhostMode;
    }
}

// Processes entering ghost house state
void GhostEntering(unsigned char index) {
    // If not fully in the ghost house yet
    if (EntityY[index] != 140) {
        // If right of horizontal center of ghost house, move left
        if (EntityX[index] > 128) {
            // Set to pixel movement to avoid overshooting pixel target
            EntitySpeed[index] = 1;
            EntitySubSpeed[index] = 0;
            EntityDir[index] = DIRECTION_LEFT;
            MoveEntity(index, DIRECTION_LEFT);
        // If left of horizontal center of ghost house, move right
        } else if (EntityX[index] < 128) {
            // Set to pixel movement to avoid overshooting pixel target
            EntitySpeed[index] = 1;
            EntitySubSpeed[index] = 0;
            EntityDir[index] = DIRECTION_RIGHT;
            MoveEntity(index, DIRECTION_RIGHT);
        // At center, move down
        } else {
            EntityDir[index] = DIRECTION_DOWN;
            MoveEntity(index, DIRECTION_DOWN);
            // If vertical position is at threshold maximum
            if (EntityY[index] >= 140) {
                // Set to vertical max
                EntityY[index] = 140;
                // If Blinky or Pinky, we're done, change state
                if (index == INDEX_BLINKY || index == INDEX_PINKY) {
                    EntityState[index] = ENTITY_STATE_LEAVING;
                }
            }
        }
    // When fully in the ghost house, move Inky and Sue to the left and right respectively
    } else {
        switch (index) {
            case INDEX_INKY:
                // Move left until at horizontal position
                if (EntityX[index] > 112) {
                    EntityDir[index] = DIRECTION_LEFT;
                    MoveEntity(index, DIRECTION_LEFT);
                // Refreshed, change state to leaving
                } else {
                    EntityState[index] = ENTITY_STATE_LEAVING;
                }
            break;
            case INDEX_SUE:
                // Move right until at horizontal position
                if (EntityX[index] < 144) {
                    EntityDir[index] = DIRECTION_RIGHT;
                    MoveEntity(index, DIRECTION_RIGHT);
                // Refreshed, change state to leaving
                } else {
                    EntityState[index] = ENTITY_STATE_LEAVING;
                }
            break;
        }
    }
}

// Processes points state
void GhostPoints(unsigned char index) {
    // Wait, show points
    if (EntityIncrementTimer(index, TIME_60) == 1) {
        // Set ghost to chomped state
        EntityState[index] = ENTITY_STATE_CHOMPED;
        // Unpause
        Paused = 0;
        // Show player, by changing player state
        EntityState[EntityTarget[index]] = ENTITY_STATE_MOVING;
    }
}

// Blinky chase behavior
void BlinkyChase(unsigned char target) {
    GhostMoveTowardsTarget(INDEX_BLINKY, EntityTile[target]);
}

// Pinky chase behavior
void PinkyChase(unsigned char target) {
    // Get four tiles ahead of player position / direction
    switch (EntityDir[target]) {
        case DIRECTION_DOWN: GhostMoveTowardsTarget(INDEX_PINKY, EntityTile[target] + 128); return;
        case DIRECTION_LEFT: GhostMoveTowardsTarget(INDEX_PINKY, EntityTile[target] - 4); return;
        case DIRECTION_UP: GhostMoveTowardsTarget(INDEX_PINKY, EntityTile[target] - 128); return;
        default: GhostMoveTowardsTarget(INDEX_PINKY, EntityTile[target] + 4); return;
    }
}

// Inky chase behavior
void InkyChase(unsigned char target) {
    // Get tiled coordinates for the target's position
    unsigned char x1 = EntityX[target] >> 3;
    unsigned char y1 = EntityY[target] >> 3;
    // Get tiled coordinates for Blinky's position
    unsigned char x2 = EntityX[INDEX_BLINKY] >> 3;
    unsigned char y2 = EntityY[INDEX_BLINKY] >> 3;
    // Increase by 2 tiles in front of target
    switch (EntityDir[target]) {
        case DIRECTION_DOWN: y1 += 2; break;
        case DIRECTION_LEFT: x1 -= 2; break;
        case DIRECTION_UP: y1 -= 2; break;
        default: x1 += 2; break;
    }
    // Get number of tiles between entities
    unsigned char x = x1 > x2 ? x1 - x2 : x2 - x1;
    unsigned char y = y1 > y2 ? y1 - y2 : y2 - y1;
    // If the target's horizontal direction is greater or equal to Inky's
    if (x1 >= x2) {
        x1 += x;
    } else {
        x1 -= x;
    }
    // If the target's vertical direction is greater or equal to Inky's
    if (y1 >= y2) {
        y1 += y;
    } else {
        y1 -= y;
    }
    // Move towards target tile id
    GhostMoveTowardsTarget(INDEX_INKY, (y1 << 5) + x1);
}

// Sue chase behavior
void SueChase(unsigned char target) {
    // If 8 tiles outside of player, target player
    if (GetDistance(EntityTile[INDEX_SUE], EntityTile[target]) >= 64) {
        GhostMoveTowardsTarget(INDEX_SUE, EntityTile[target]);
    // Target scatter tile
    } else {
        GhostMoveTowardsTarget(INDEX_SUE, ScatterTargets[INDEX_SUE]);
    }
}

// Gets target index based on game mode and current player
unsigned char GetGhostTargetIndex(unsigned char index) {
    // If game mode is team, get random
    if (GameMode == GAME_MODE_TEAM_PLAY) {
        return GetRng(7, index) + INDEX_PLAYER_01;
    }
    // Target current player
    return CurrentPlayer;
}

// Checks if the given ghost's tile position changed since last frame
// If it has not, perform collision checks, and move entity in current direction
// Returns if position changed
unsigned char GhostPositionChanged(unsigned char index) {
    // If no change in tile position, return
    if (EntityPrevTile[index] == EntityTile[index]) {
        // Check for player collisions
        GhostCheckCollision(index);
        CheckWrap(index);
        // Move entity
        MoveEntity(index, EntityDir[index]);
        return 0;
    }
    // Processing ghost
    if (GhostProcessing == 0) {
        GhostProcessing = 1;
        return 1;
    }
    // Not processing anything
    return 0;
}

// Processes frightened state
void GhostFrightened(unsigned char index) {
    // Set given state when timer expires
    if (EnergizerTimer <= 0) {
        ResetGhostFrame(index);
        EntityState[index] = GhostMode;
        return;
    }
    // If no change in tile position, skip targeting logic
    if (GhostPositionChanged(index) == 0) {
        return;
    }
    // Move in random direction
    GhostMoveTowardsTarget(index, 65535);
}

// Processes chomped state
void GhostChomped(unsigned char index) {
    // If at entrance, set state to entering
    if (EntityTile[index] == 463 || EntityTile[index] == 464) {
        EntityState[index] = ENTITY_STATE_ENTERING;
        return;
    }
    // If no change in tile position, skip targeting logic
    if (GhostPositionChanged(index) == 0) {
        return;
    }
    // Move ghost towards ghost house entrance
    GhostMoveTowardsTarget(index, 463);
}

// Processes scatter state
void GhostScattering(unsigned char index) {
    // If no change in tile position, skip targeting logic
    if (GhostPositionChanged(index) == 0) {
        return;
    }
    // If ghost is Inky or Sue, set corner from target array
    if (index > INDEX_PINKY) {
        GhostMoveTowardsTarget(index, ScatterTargets[index]);
    // Set random corner for Blinky and Pinky
    } else {
         GhostMoveTowardsTarget(index, ScatterTargets[GetRng(6, GhostOffsets[index])]);
    }
}

// Processes ghost chasing state
void GhostChasing(unsigned char index) {
    // If no change in tile position, skip targeting logic
    if (GhostPositionChanged(index) == 0) {
        return;
    }
    // Get target tile index
    unsigned char target = GetGhostTargetIndex(index);
    // Set target based on ghost
    switch (index) {
        case INDEX_BLINKY: BlinkyChase(target); break;
        case INDEX_PINKY: PinkyChase(target); break;
        case INDEX_INKY: InkyChase(target); break;
        case INDEX_SUE: SueChase(target); break;
    }
}

#ifdef TIME_NTSC
    // Sets ghost speed based on state and stage number
    void SetGhostSpeed(unsigned char index) {
        // If running a scen return
        if (EntityState[index] == ENTITY_STATE_SCENE || ENTITY_STATE_NONE) {
            return;
        }
        // Set speed based on current state and stage
        if (EntityState[index] == ENTITY_STATE_FRIGHTENED || EntityState[index] == ENTITY_STATE_HOUSE || EntityState[index] == ENTITY_STATE_LEAVING) {
            EntitySpeed[index] = 0;
            EntitySubSpeed[index] = 128;
        } else if (EntityState[index] == ENTITY_STATE_CHOMPED || EntityState[index] == ENTITY_STATE_ENTERING) {
            EntitySpeed[index] = 2;
            EntitySubSpeed[index] = 0;
        // Slow down in tunnels
        } else if (GetMapTileId(EntityTile[index]) == TILE_TUNNEL) {
            EntitySpeed[index] = 0;
            EntitySubSpeed[index] = 96;
            return;
        } else {
            // Stage 1: 240, lvls 2-4: 16, lvs 5+: 48
            if (Stage == 0) {
                EntitySpeed[index] = 0;
                EntitySubSpeed[index] = 240;
            } else if (Stage < 4) {
                EntitySpeed[index] = 1;
                EntitySubSpeed[index] = 16;
            } else {
                EntitySpeed[index] = 1;
                EntitySubSpeed[index] = 48;
            }
        }
    }
#else
    // Sets ghost speed based on state and stage number
    void SetGhostSpeed(unsigned char index) {
        // If running a scen return
        if (EntityState[index] == ENTITY_STATE_SCENE || ENTITY_STATE_NONE) {
            return;
        }
        // Set speed based on current state and stage
        if (EntityState[index] == ENTITY_STATE_FRIGHTENED || EntityState[index] == ENTITY_STATE_HOUSE || EntityState[index] == ENTITY_STATE_LEAVING) {
            EntitySpeed[index] = 0;
            EntitySubSpeed[index] = 128;
        } else if (EntityState[index] == ENTITY_STATE_CHOMPED || EntityState[index] == ENTITY_STATE_ENTERING) {
            EntitySpeed[index] = 2;
            EntitySubSpeed[index] = 0;
        // Slow down in tunnels
        } else if (GetMapTileId(EntityTile[index]) == TILE_TUNNEL) {
            EntitySpeed[index] = 0;
            EntitySubSpeed[index] = 96;
            return;
        } else {
            // Stage 1: 240, lvls 2-4: 16, lvs 5+: 48
            if (Stage == 0) {
                EntitySpeed[index] = 0;
                EntitySubSpeed[index] = 240;
            } else if (Stage < 4) {
                EntitySpeed[index] = 1;
                EntitySubSpeed[index] = 16;
            } else {
                EntitySpeed[index] = 1;
                EntitySubSpeed[index] = 48;
            }
        }
    }
#endif

// Updates ghost state
void UpdateGhostState(unsigned char index) {
    // Get state
    unsigned char state = EntityState[index];
    // Set ghost's tile index
    EntityTile[index] = PositionToTileOffset(index);
    // If not running the game play, or if game paused and not in pause override state, return
    if (SubState > 4 || (Paused > 0 && state != ENTITY_STATE_POINTS && state != ENTITY_STATE_CHOMPED && state != ENTITY_STATE_ENTERING)) {
        return;
    }
    // Set speed
    SetGhostSpeed(index);
	// Update ghost state
	switch (state) {
        case ENTITY_STATE_HOUSE: GhostHouse(index); break;
        case ENTITY_STATE_LEAVING: GhostLeaving(index); break;
        case ENTITY_STATE_ENTERING: GhostEntering(index); break;
        case ENTITY_STATE_SCATTERING: GhostScattering(index); break;
        case ENTITY_STATE_CHASING: GhostChasing(index); break;
        case ENTITY_STATE_FRIGHTENED: GhostFrightened(index); break;
        case ENTITY_STATE_CHOMPED: GhostChomped(index); break;
        case ENTITY_STATE_POINTS: GhostPoints(index); break;
	}
}

// Updates ghost
void UpdateGhost(unsigned char index) {
    UpdateGhostSprites(index);
    UpdateGhostState(index);
    UpdateGhostFrame(index);
}